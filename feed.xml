<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nani</title>
    <description>我的要博客简单专注有内容。
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 16 Mar 2017 14:56:25 +0800</pubDate>
    <lastBuildDate>Thu, 16 Mar 2017 14:56:25 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>webpack 详细介绍翻译</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;使用webpack已经很长一段时间了，对于React的开发，它确实是非常适用的工具。不过webpack官方提供的文档，确实有点混乱，不好理解。最近看到了一篇介绍webpack的文章，说的非常的详细，由浅入深，相信可以解答一些关于webpack的困惑。抽时间翻译了一下，原文可以连接&lt;a href=&quot;https://www.smashingmagazine.com/2017/02/a-detailed-introduction-to-webpack/&quot;&gt;A Detailed Introduction To Webpack&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;JavaScript模块打包已经出现有一段时间了，RequireJs在2009第一次实现，然后有Browserify登台，之后又一些其他的打包工具流传开来。在这些工具中，做为最好之一的webpack引起了人们的关注。如果你不熟悉它，我希望这篇文章对你有开始使用它所帮助。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;什么是模块打包工具&lt;/h4&gt;
&lt;p&gt;在大多数的编程语言中（包括最新的没有被浏览器全部实现的ES6+）,你可以将你的代码拆分成多个文件（一般一个文件代表一个模块），之后在你的应用中引入这些模块，以使用这些模块所提供的功能。但浏览器没有内置类似的功能，所以需要模块打包工具来实现响应的功能，这些功能主要包括：异步的加载这些模块并且在加载完后允许它们，或者将所有依赖的模块合并成一个单一的JavaScript文件并以HTMl的&amp;lt;script&amp;gt;标签的形式加载.&lt;/p&gt;

&lt;p&gt;如果没有这些模块打包的工具，我们就需要自己进行手动的文件合并或者按顺序在HTML中加载相应的&amp;lt;script&amp;gt;标签，但这样做有很多坏处：&lt;/p&gt;

&lt;p&gt;  1. 首先你得记录文件加载的正确顺序，包括文件依赖了哪些文件，而且不要加载一些你不会用的文件。&lt;br /&gt;
  2. 过多的&amp;lt;script&amp;gt;标签意味着更多的服务端的请求，影响性能。&lt;br /&gt;
  3. 很明显这需要很多的人工劳动，而原本这些都可以交给计算机来帮我们完成的。&lt;/p&gt;

&lt;p&gt;大多数的模块打包工具还与npm，Bower集成方便你轻松的加载需要的第三方依赖。只需要安装这些依赖然，之后在你的应用中引入它们就可以使用它们提供的功能了。如果你能正确的配置你打包工具，你可以确保你依赖的第三方工具都是独立的文件，这样当你更新了你的应用的代码之后，用户那边更新缓存时也不用再下载这些文件了，因为这些文件本身没有发生变化（当然这还得看你的http缓存指令）。&lt;/p&gt;

&lt;h4 id=&quot;webpack&quot;&gt;为什么使用webpack&lt;/h4&gt;
&lt;p&gt;现在你明白了我们使用模块打包工具的一些基本的原因，那么为什么在这么多工具中我们要选择webpack呢？有一下几点原因：&lt;/p&gt;

&lt;p&gt;  1. 相对较新，有了其他打包工具的经验，使得它避免一些老的打包工具的缺陷和问题。&lt;br /&gt;
  2. 入手简单，如果你只需要将一些JavaScript文件打包不需要其他配置，你可以连配置文件都不用写。 &lt;br /&gt;
  3. 插件系统，让它做更多的事情，扩展出更多的功能，所以它能成为你需要的唯一打包工具。&lt;/p&gt;

&lt;p&gt;我只看过几个模块打包和构建工具可以做到相同的事情，但比起它们webpack还有一个优势：一个可以非常大的社区，它可以在你遇到问题时帮助你。Browserify的社区也很大，但它缺少一些webpack包含的潜在的基本功能。听了我这么多对webpack的赞扬，你肯定迫不及待的想看看具体的实例。所以Let’do that。&lt;/p&gt;

&lt;h4 id=&quot;webpack-1&quot;&gt;安装webpack&lt;/h4&gt;
&lt;p&gt;在使用webpack之前我们需要安装它。安装之前，我们需要Node.js和npm，我假设你都已经安装好了，如果你还有没有安装，&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js官网&lt;/a&gt;是一个很好的开始的地方。&lt;/p&gt;

&lt;p&gt;安装webpack有两种方式：全局安装和本地安装。如果你使用全局安装，你可以在任何地方使用它，但这样做webpack就不会作为你项目的依赖而包含在内，所以你就不能在不同的项目中使用不同版本的webpack（比如你开始一个新的项目，需要更多的功能，所以你升级到版本，而那些老的项目又不能兼容，这种情况很常见），因为你的webpack是全局的。所以，我建议本地安装CLI包，并使用相对路径或者npm script来运行。如果你还没有本地安装CLI包，你可以阅读这篇&lt;a href=&quot;https://www.joezimjs.com/javascript/no-more-global-npm-packages/&quot;&gt;文章&lt;/a&gt;了解详细。&lt;/p&gt;

&lt;p&gt;后面我们会使用npm script的方式，所以你可以先不用看本地安装的内容。首先：创建一个文件夹作为你项目的根目录，作为我们学习和实验webpack的地方，&lt;a href=&quot;https://github.com/joezimjs/webpack-Introduction-Tutorial&quot;&gt;GitHub&lt;/a&gt;有相应的代码你可以clone使用，当然你也可以自己跟着创建相应的文件。&lt;/p&gt;

&lt;p&gt;现在我们进入你项目的根目录，你应该会运行npm init来初始化你项目，后面需要填写的内容不是很重要，除非你希望在npm上发布你包。&lt;/p&gt;

&lt;p&gt;现在你有了一个package.json的文件（当你执行npm init创建时创建的），你项目所有的依赖信息都在这个文件里。现在让我们将webpack作为我们项目的第三方依赖进行安装，执行：npm install webpack -D。(-D 意思是将依赖的信息写入到package.json，你也可以使用–save-dev)。&lt;/p&gt;

&lt;p&gt;在我们可以使用webpack之前，我们应该有一个简单的应用去测试它。我说简单的应用，因为它确实很简单。不过在这之前我们先安装Lodash以便我们可以在我们的应用中测试第三方的依赖：&lt;code&gt;nmp install lodash -S&lt;/code&gt;（-S同上面的–save）。之后我们创建一个名为&lt;code&gt;src&lt;/code&gt;的文件夹，然后在里面编写一个名为main.js的文件，内容为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var map = require(&#39;lodash/map&#39;);

function square(n) {
    return n*n;
}

console.log(map([1,2,3,4,5,6], square));
&lt;/pre&gt;

&lt;p&gt;非常简单，对吧。我们只是创建了包含了1~6的整数的数组，然后使用Lodash的map函数创建一个新数组，新数组的每一个项的值是原数组的每一项的平方，最后我们打印出这个新数组。你可以使用Node.js运行这个文件：&lt;code&gt;node src/main.js&lt;/code&gt;，最后的输出应该是：&lt;code&gt;[1,4,9,16,25,36]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但我们真正想要实现的是将这个文件和Lodash的代码进行打包一边我们的浏览器可以真正的运行它，也就是webpack应该做的工作，我们应该怎么做呢？&lt;/p&gt;

&lt;h4 id=&quot;webpack-2&quot;&gt;使用webpack提供的命令&lt;/h4&gt;
&lt;p&gt;不写配置文件而直接使用webpack最简单的方式就是使用webpack提供的命令。在这些命令中最简单的就是只提供一个入口文件路径和一个出口文件路径就行了。webpack会读取入口文件，然后追钟它的依赖树，之后将依赖的文件合并为一个单一的文件，最后将这个文件产出到你指定的产出路径中，文件名为你指定的文件名。比如这里的，我们的入口文件是&lt;code&gt;src/main.js&lt;/code&gt;，我们希望打包到&lt;code&gt;dist/bundle.js&lt;/code&gt;。当然我们可以创建一个npm script来实现（我们没有全局的安装webpack，所以我们不能直接运行webpack命令）。在package.json，我们像下面这样编写”script”字段：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
…
 &quot;script&quot;: {
   &quot;build&quot;: &quot;webpack src/main.js dist/bundle.js&quot;,
  }
…
&lt;/pre&gt;

&lt;p&gt;然后，如果你运行&lt;code&gt;npm run build&lt;/code&gt;，webpack便开始工作了。当执行完之后，我们变会得到一个新的dist/bundle.js的文件。现在你可以执行这个文件了，不论是Node.js还是浏览器得到的结果应该都是一样的。&lt;/p&gt;

&lt;p&gt;在我们进一步探索webpack之前，让我们先编写一个稍微专业一点的npm script，实现在打包之前先删除&lt;code&gt;dist&lt;/code&gt;目录以及其中的文件的功能，以及增加一下脚本来执行我们的打包。首先我们需要做的是安装&lt;code&gt;del-cli&lt;/code&gt;，这样我们就可以实现删除目录，而且不用担心那些和我们使用不同操作系统的人删除命令是否有效的问题了。&lt;code&gt;npm install del-cli -D&lt;/code&gt;。之后更新我们的npm script脚本：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
…
 &quot;script&quot;: {
   &quot;prebuild&quot;: &quot;del-cli dist -f&quot;,
   &quot;build&quot;: &quot;webpack src/main.js dist/bundle.js&quot;,
   &quot;execute&quot;: &quot;node dist/bundle.js&quot;,
   &quot;start&quot;: &quot;npm run build -s &amp;amp;&amp;amp; npm run execute -s&quot;
  }
…
&lt;/pre&gt;

&lt;p&gt;这里我们没有改写&lt;code&gt;build&lt;/code&gt;的部分，但是提供了清除&lt;code&gt;dist&lt;/code&gt;目录的&lt;code&gt;prebuild&lt;/code&gt;命令。每次我们执行&lt;code&gt;build&lt;/code&gt;命令前都会先执行这里的&lt;code&gt;prebuild&lt;/code&gt;命令。我们还加入了&lt;code&gt;execute&lt;/code&gt;命令，使用Node.js执行打包命令。当然我们可以使用&lt;code&gt;start&lt;/code&gt;一条命令执行所以的任务（-s参数目的是在console中不产生其他没有用的信息）。当我们执行&lt;code&gt;npm start&lt;/code&gt;，你就能很快看见webpack的产出了，也就是命令行打印出来的新的数组。如果你得到这样的结果，那么恭喜你，你已经完成了我们的第一个示例了。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;使用配置文件&lt;/h4&gt;
&lt;p&gt;和上面我们使用命令行开始学习使用webpack一样有趣，如果你想了解更多的关于webpack的特性，命令很多的时候，你就会希望把你命令移到一个配置文件中去，而不是全部使用命令行的方式，这样做有很多原因，主要就是配置文件的方式更加灵活，功能更强大，而且可读性更强，因为它是用JavaScript编写的。&lt;/p&gt;

&lt;p&gt;所以我们先创建一个配置文件，只需要在你的项目的根目录中新建一个叫webpack.config.js的文件就行了。webpack会默认寻找这个文件进行配置，当然你也可以自定义默认配置文件的文件名和路径，只需要在使用命令时传入一个参数&lt;code&gt;--config [filename]&lt;/code&gt;就行了。&lt;/p&gt;

&lt;p&gt;在这篇教程中，我们使用标准的文件名。现在我们尝试将上面使用过的示例通过配置文件的方式来实现，为了实现它，我们需要在我们的&lt;code&gt;webpack.config.js&lt;/code&gt;文件中添加如下代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
module.exports = {
  entry: &#39;./src/main.js&#39;,
  output: {
    path: &#39;./dist&#39;,
    filename: &#39;bundle.js&#39;
  }
};
&lt;/pre&gt;

&lt;p&gt;在配置文件中，我们说明了入口文件和产出文件，和我们在上面使用命令行的方式很相似。注意这是一个JavaScript文件，而不是一个JSON文件，所以我需要导出配置对象（configuration object），及这里的&lt;code&gt;module.export&lt;/code&gt;。虽然这样看起来并没有我们使用命令好看，但不要着急，在我们的教程结尾时，你就会发现这很有用了。&lt;/p&gt;

&lt;p&gt;现在我们就可以删除&lt;code&gt;package.json&lt;/code&gt;中那些传给webpack的参数了，你的脚本看起来应该差不多像这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
…
 &quot;script&quot;: {
   &quot;prebuild&quot;: &quot;del-cli dist -f&quot;,
   &quot;build&quot;: &quot;webpack&quot;,
   &quot;execute&quot;: &quot;node dist/bundle.js&quot;,
   &quot;start&quot;: &quot;npm run build -s &amp;amp;&amp;amp; npm run execute -s&quot;
  }
…
&lt;/pre&gt;

&lt;p&gt;你可以象上面那样运行&lt;code&gt;npm start&lt;/code&gt;，之后的输出你应该很熟悉。这就是我们的第二个示例了。&lt;/p&gt;

&lt;h4 id=&quot;loaders&quot;&gt;使用Loaders&lt;/h4&gt;
&lt;p&gt;通常来讲我们有两种方式扩展webpack的功能：loaders(加载器) 和 plugins（插件）。插件我们会在后面讨论，我们先看一下loaders。loaders的主要功能是对给定类型的文件进行转换或是操作得到相应的输出。对单一类型的文件你可以链式的调用多个loader进行处理，如果你使用过gulp你就很容易明白,，它有点类似gulp中的task，就像我们在工厂中经常看到的流水线一样，我们的loader就像流水线上的各类工序，经过链式的层层加工处理，最终得到我们想要的产出。例如，你可以指定我们的&lt;code&gt;.js&lt;/code&gt;文件，先使用ESLint进行预处理，之后在使用Babel将es6解析成es5。如果ESLint的执行过程中出现了错误，将会在console中打印出相应的信息，一旦链式中的一环出现了问题，webpack就会停止工作了。&lt;/p&gt;

&lt;p&gt;对于我们这里的这个小应用程序来说，为了能尽量先简单起见，我暂时不在webpack中加入linting的功能，只是想是webpack能利用Babel将ES6解析为ES5。当然，为了测试，我们先得有一些ES6的代码对吧，所以我们将我们的&lt;code&gt;main.js&lt;/code&gt;用ES6改写一下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
  import {map} from &#39;lodash&#39;;

  console.log(map[1,2,3,4,5,6], n =&amp;gt; n * n);
&lt;/pre&gt;

&lt;p&gt;上面的代码在功能上还是一样的，不同的是我们使用了箭头函数来代替&lt;code&gt;square&lt;/code&gt;函数，另一方面，我使用了&lt;code&gt;import&lt;/code&gt;关键字来加载&lt;code&gt;lodash&lt;/code&gt;模块，这些都是ES6中的语法。这样实际上会加载的是一个全量的Lodash的文件在我们进行打包的时候，而不是只是按需要的只加载&lt;code&gt;lodash/map&lt;/code&gt;。当然你可以重新写一下第一行代码，改成&lt;code&gt;import {map} from &#39;lodash&#39;&lt;/code&gt;来改善。我这里之所没有这样去改，主要是因为：&lt;br /&gt;
  1. 在一些大型的应用中，你可能会使用Lodash库中很多功能，所以你可能需要加载全部。&lt;br /&gt;
  2. 如果你在使用Backbone.js，你就会知道，分开单独的加载所需的函数是非常困难的，因为没有文档告诉你它需要的依赖是哪些。&lt;br /&gt;
  3. 在下一个版本的webpack中，开发者计划包含构建文件依赖树之类的功能，这样就可以去掉那些没用被使用的模块了，所以我们这样写在下一个版本中仍可以正常工作。&lt;br /&gt;
  4. 我想让它作为一个示例来强调一下上面关于打包的一些要点。&lt;/p&gt;

&lt;p&gt;（注意：这两种加载Lodash的方式都可以正常工作的原因是，Lodash的开发者提供了这样的功能，并不是所有的库都可以这样工作的）。&lt;/p&gt;

&lt;p&gt;总之，我们有了ES6的代码了，现在我们的任务是将它解析为ES5，以便可以在我们的浏览器中使用。首先，我们需要Babel以及Babel关于webpack的一些依赖，这样Babel才能在webpack中正常运行起来。最少的话，我们需要&lt;a href=&quot;https://www.npmjs.com/package/babel-core&quot;&gt;babel-core&lt;/a&gt;（Babel的核心功能，执行绝大多数的工作），&lt;a href=&quot;https://www.npmjs.com/package/babel-loader&quot;&gt;babel-loader&lt;/a&gt;（webpack loader可以调用babel-core的接口），&lt;a href=&quot;https://www.npmjs.com/package/babel-preset-es2015&quot;&gt;babel-preset-es2015&lt;/a&gt;（包含Bable将ES6转换为ES5的转码规则）。同时我们也会安装&lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-runtime&quot;&gt;bable-plugin-transform-runtim&lt;/a&gt;和&lt;a href=&quot;https://www.npmjs.com/package/babel-polyfill&quot;&gt;babel-polyfill&lt;/a&gt;两个模块。具体可以查看这里&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/01/babel.html&quot;&gt;Babel入门教程&lt;/a&gt;和这里介绍Babel各种插件的&lt;a href=&quot;https://github.com/brunoyang/blog/issues/20&quot;&gt;Bable全家桶&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;好了，现在让我们来安装这些依赖吧：&lt;code&gt;npm i -D babel-core bable-loader bable-preset-es2015 bable-plugin-transform-runtime bable-polyfill&lt;/code&gt;。之后我们来编写配置文件&lt;code&gt;webpack.config.js&lt;/code&gt;，首先我们需要在文件中找个地方添加我们的loader，修改&lt;code&gt;webpack.config.js&lt;/code&gt;文件之后像这样。&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
module.exports = {
  entry: &#39;.src/main.js&#39;,
  output: {
    path: &#39;./dist&#39;,
    filename: &#39;bundle.js&#39;
  },
  module: {
    rules: [
      …			   
    ]
  }
}
&lt;/pre&gt;

&lt;p&gt;这里我们添加了一个命名&lt;code&gt;module&lt;/code&gt;的字段，&lt;code&gt;module&lt;/code&gt;中包含值一个rules的字段，rules是一个数组，这个数组包含了每个loader的配置内容。这是我们将要添加babel-loader的地方。对于每一个loader我们最少需要配置两个参数：&lt;code&gt;test&lt;/code&gt;和&lt;code&gt;loader&lt;/code&gt;，test通常是一个说明每个文件的绝对路径的正则表达式。这些正则表达式通常用来匹配文件的类型，比如&lt;code&gt;/\.js$/&lt;/code&gt;匹配&lt;code&gt;.js&lt;/code&gt;文件，在我们后面的示例文件中，我们编写为&lt;code&gt;/\.jsx?$/&lt;/code&gt;匹配&lt;code&gt;js&lt;/code&gt;和&lt;code&gt;jsx&lt;/code&gt;文件，如果你希望在项目中加入react代码。之后我们需要配置&lt;code&gt;loader&lt;/code&gt;参数，告诉webpack使用那些loader来处理&lt;code&gt;test&lt;/code&gt;匹配出来的文件。&lt;/p&gt;

&lt;p&gt;这里我们只需依次传入loader的名称就可以了，名称直接使用&lt;code&gt;!&lt;/code&gt;连接，就像这样：&lt;code&gt;bable-loader!eslint-loader&lt;/code&gt;。webpack会&lt;strong&gt;&lt;code&gt;从右往左&lt;/code&gt;&lt;/strong&gt;的读取配置，所以这里&lt;code&gt;eslint-loader&lt;/code&gt;会先执行，而&lt;code&gt;bable-loader&lt;/code&gt;后执行。如果你想为一些loader需要指定特定的参数，你可以使用query语法，比如为Bable指定&lt;code&gt;fakeoption&lt;/code&gt;参数为&lt;code&gt;true&lt;/code&gt;：&lt;code&gt;bable-loader?fakeopton=true!eslint-loader&lt;/code&gt;。你也可以使用&lt;code&gt;use&lt;/code&gt;代替loader来指定需要的loaders，&lt;code&gt;use&lt;/code&gt;使用数组而不是字符串，这样看起来可能会清晰一些：&lt;code&gt;use:[&#39;bable-loader?fakeoption=true&#39;, &#39;eslint-loader&#39;]&lt;/code&gt;，这样有很多的loader的时候，更方便阅读。&lt;/p&gt;

&lt;p&gt;因为Bable是我们示例里唯一的loader，所以我们关于loader的配置大概像这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
…			   
  rules: [
    {test: /\.jsx?$/, loader: &#39;bable-loader&#39;}
  ]
…			   
&lt;/pre&gt;

&lt;p&gt;如果你像我们这里一样只使用了一个loader，那么除了上面说的&lt;code&gt;query&lt;/code&gt;的方式指定loader参数外，你还可以使用&lt;code&gt;options&lt;/code&gt;对象，采用键值对的方式，比如上面的例子，还可以这样写：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
…			   
  rules: [
    {
      test: /\.jsx?$/, 
      loader: &#39;bable-loader&#39;,
      options: {
        fakeoption: true
      }
    }
  ]
…			   
&lt;/pre&gt;

&lt;p&gt;我们这里采用了这样的语法，为Bable指定了几个参数：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
…			   
  rules: [
    {
      test: /\.jsx?$/, 
      loader: &#39;bable-loader&#39;,
      options: {
        plugins: [&#39;transform-runtime&#39;],
        presets: [&#39;es2015&#39;]
      }
    }
  ]
…			   
&lt;/pre&gt;

&lt;p&gt;首先需要配置ES6的语法规则，这样才能将ES6解析为ES5，同时我们也配置了transform-runtime插件，当然这个插件不是必须的。还有一种可选的方案就是使用&lt;code&gt;.babelrc&lt;/code&gt;文件来配置这些参数，但后面我不会告诉你怎么做，通常我建议使用&lt;code&gt;.babelrc&lt;/code&gt;进行配置，但为了更好的说明webpack的配置，我们采用在webpack的配置文件中配置。&lt;/p&gt;

&lt;p&gt;配置到这里，我们只差一件是就可以完成loader的配置了。我们需要告诉Babel&lt;code&gt;node_modules&lt;/code&gt;目录下的文件是不需要进行解析的，这样可以提高我们打包的效率。我们可以使用&lt;code&gt;exclude&lt;/code&gt;来指定哪些目录下的文件不需要做处理。&lt;code&gt;exclude&lt;/code&gt;的值也是一个正则表达式，我们的项目中可以这样配置：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
…			   
  rules: [
    {
      test: /\.jsx?$/, 
      loader: &#39;bable-loader&#39;,
      exclude: /node_modules/,
      options: {
        plugins: [&#39;transform-runtime&#39;],
        presets: [&#39;es2015&#39;]
      }
    }
  ]
…			   
&lt;/pre&gt;

&lt;p&gt;或者，我们可以使用&lt;code&gt;include&lt;/code&gt;来指定只解析&lt;code&gt;src&lt;/code&gt;目录，道理差不多。现在，你运行&lt;code&gt;npm start&lt;/code&gt;可以发现ES6代码解析成了ES5，执行的结果同上。如果你希望使用&lt;code&gt;polyfill&lt;/code&gt;插件而不是&lt;code&gt;transform-runtime&lt;/code&gt;插件，你只需要修改两处就行了，先删除&lt;code&gt;[&#39;transform-runtime&#39;]&lt;/code&gt;然后在&lt;code&gt;entry&lt;/code&gt;中加入&lt;code&gt;babel-polyfill&lt;/code&gt;即可。&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
entry: [
  &#39;babel-polyfill&#39;,
  &#39;./src/main.js&#39;
]			   
&lt;/pre&gt;

&lt;p&gt;除了使用webpack的配置文件，我们也可以在&lt;code&gt;src/main.js&lt;/code&gt;文件中加入&lt;code&gt;import &#39;babel-polyfill&#39;&lt;/code&gt;，最后的效果都是一样的。我们这里采用了在webpack的配置文件中添加的方式，主要是因为这我们后面的示例需要这样做，而且这样也是很好的例子，说明了如何将多个文件打包到一起。总之，这是我们的第三个示例，你可以运行&lt;code&gt;npm start&lt;/code&gt;，结果应该和上面的结果是一致的。&lt;/p&gt;

&lt;h4 id=&quot;handlebars-loader&quot;&gt;使用Handlebars-loader&lt;/h4&gt;
&lt;p&gt;让我再加入一个新的的loader：handlebars-loader。handlebars-loader会将Handlebars模板文件解析为一个JavaScript函数，当我们在其他JavaScript文件中import这个模板文件时（&lt;code&gt;import template from &#39;./handlebars.hbs&#39;&lt;/code&gt;）。这个函数会被导入到JavaScript中。这是我喜欢webpack loader的一个重要原因：你可以import非JavaScript文件，并将它们全部打到一个包中，这些文件会被处理成能被JavaScript处理的形式。还有一个经常使用到的例子,就是我们可以使用loader将图片解析为base64编码，最后利用JavaScript在页面中输出图片。如果你合理利用多种loader，你甚至可以做到减少图片的大小，提升性能。&lt;/p&gt;

&lt;p&gt;照例，我们首先需要安装这个loader：&lt;code&gt;npm i -D handlebars-loader&lt;/code&gt;。如果你尝试使用他，你会发现它还不能工作，因为你还需要Handlebars本身：&lt;code&gt;npm i -D handlebars&lt;/code&gt;。这里你可以自行控制Hanldebars的版本，不需要和handlebars-loader的版本保持同步，因为它们是相互独立的。&lt;/p&gt;

&lt;p&gt;在我们已经成功安装上面两个模块之后，我们现在需要一个handlebars模板来进行后面的工作。所以让我们来编写一个handlebars模板文件，&lt;code&gt;numberlist.hbs&lt;/code&gt;，放到我们的src目录中就可以了。&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;ul&amp;gt;
  &amp;#123;&amp;#123;#each numbers as | number i|}}
    &amp;lt;li&amp;gt;&amp;#123;&amp;#123;number}}&amp;lt;li&amp;gt;
  &amp;#123;&amp;#123;/each}}
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;

&lt;p&gt;这个模板的功能是很明显的，就是产生一个无序列表&lt;code&gt;ul&lt;/code&gt;，列表的每一项的值是数组&lt;code&gt;numbers&lt;/code&gt;的各个项。&lt;/p&gt;

&lt;p&gt;好了，现在我们修改一下我们的&lt;code&gt;main.js&lt;/code&gt;文件，这次是使用模板文件来产生一个无序列表，而不是像原来一样只是输出数组而已。修改完了之后，你的&lt;code&gt;main.js&lt;/code&gt;文件看起来大概像这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
import {map} from &#39;lodash&#39;;
import template from &#39;./numberlist.hbs&#39;;

let numbers = map([1,2,3,4,5,6], n =&amp;gt; n&amp;#42;n);
console.log(template({numbers}))
&lt;/pre&gt;

&lt;p&gt;如果你现在运行&lt;code&gt;npm start&lt;/code&gt;，你会发现它还不能正常工作，因为我们的webpack还不知道怎样加载&lt;code&gt;numberlist.hbs&lt;/code&gt;这个文件，&lt;code&gt;numberlist.hbs&lt;/code&gt;不是JavaScript文件，如果想让它能正常工作，我们可以对&lt;code&gt;import&lt;/code&gt;稍作修改，告诉webpack使用handlebars-loader处理。&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
import {map} from &#39;lodash&#39;;
import template from &#39;handlebars-loader!./numberlist.hbs&#39;;

let numbers = map([1,2,3,4,5,6], n =&amp;gt; n&amp;#42;n);
console.log(template({numbers}))
&lt;/pre&gt;

&lt;p&gt;这里我们在&lt;code&gt;numberlist.hbs&lt;/code&gt;文件路径的前面添加了一个loader名称作为前缀，并使用！隔开，目的就是告诉webpack使用handlebars-loader来加载&lt;code&gt;numberlist.hbs&lt;/code&gt;文件，这样我们就可以不必修改webpack配置文件了。但是在大一些的项目中，我们可能会有非常多的模板，使用配置文件来进行配置就显得更有意义了，这样我们就不必在每个文件中都加入这样的前缀了，更容易维护。所以让我们再修改一下&lt;code&gt;webpack.config.js&lt;/code&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
…			   
  rules: [
    {
      test: /\.jsx?$/, 
      loader: &#39;bable-loader&#39;,
      options: {
        plugins: [&#39;transform-runtime&#39;],
        presets: [&#39;es2015&#39;]
      }
    },
    {
      test: /\.hbs$/,
      loader: &#39;handle-loader&#39;
    }
  ]
…			   
&lt;/pre&gt;

&lt;p&gt;这个示例非常简单，我们的目的就是让webpack知道使用handerbars-loader来处理&lt;code&gt;.hbs&lt;/code&gt;类型的文件。运行&lt;code&gt;npm start&lt;/code&gt;，输出的结果大概像这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;1&amp;lt;li&amp;gt;
    &amp;lt;li&amp;gt;4&amp;lt;li&amp;gt;
    &amp;lt;li&amp;gt;9&amp;lt;li&amp;gt;
    &amp;lt;li&amp;gt;16&amp;lt;li&amp;gt;
    &amp;lt;li&amp;gt;25&amp;lt;li&amp;gt;
    &amp;lt;li&amp;gt;36&amp;lt;li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用插件&lt;/h4&gt;

</description>
        <pubDate>Tue, 21 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/technology/2017/02/21/webpack-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D-%E7%BF%BB%E8%AF%91.html</link>
        <guid isPermaLink="true">http://localhost:4000/technology/2017/02/21/webpack-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D-%E7%BF%BB%E8%AF%91.html</guid>
        
        <category>github page jekyll</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>http 缓存机制</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1.什么是缓存&lt;/h4&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2.缓存作用&lt;/h4&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3.缓存流程概览&lt;/h4&gt;
&lt;p&gt;当一条请求到达的时候，主要分为三个流程，概况起来是：&lt;strong&gt;检查命中&lt;/strong&gt;-&amp;gt;&lt;strong&gt;新鲜度检验&lt;/strong&gt;-&amp;gt;&lt;strong&gt;再验证&lt;/strong&gt;。&lt;br /&gt;
我们举一个例子来说明这个过程。&lt;br /&gt;
比如有一天我们要做一份水果沙拉，需要用到牛奶，发现这时手边没有牛奶。这时候我们首先想到的是去冰箱（缓存中）看一看有没有存货，这也就是这里的第一个流程&lt;code&gt;检查命中&lt;/code&gt;，如果没有（未命中 cache miss）这时候我们就只能去附近的超市（上一级缓存或是源服务器）从新买一些了，然后放进冰箱以备下次使用。如果发现冰箱有（命中 cache hit）存货的话，我们也不能直接拿来就用对吧，你得检查一下有没有过期呀，不然吃坏肚子怎么办。这就是我们的第二个流程&lt;code&gt;新鲜度检验&lt;/code&gt;，怎样进行新鲜度检验呢？很简单看看牛奶盒子上的过期日期不就行了么。想一想我们平时喝的牛奶上的过期信息，无非就两种，一种是直接告诉你过期的日期（比如保质期：2016-10-30），另一种就是告诉你生产日期和保存时间（比如生产日期：2016-10-1，保存时间30天）。虽然最终要表达的结果都差不多，但还是有区别的，区别就是一个是绝对时间一个是相对时间，如果要问哪个好点，应该是相对时间更好。因为使用相对时间包括起始时间，这样我们更准确的控制，而绝对时间需要一个前提，就是时间是统一的，想一想如果你的产品是要出口的话，就会有不同时区问题，你写你当地时区的绝对时间，在其他时区就可能不准了，这样就会出问题，这个服务器中就更为常见了，很多服务器的时钟不统一，有些甚至是错误的，所以我们一般建议使用相对时间。对应于上面的两种过期信息书写方式，我们的http首部中也有相应的指令来指导缓存，对于绝对过期日期，http中有对应的Expires指令，比如：Expires: Thu, 01 Dec 2016 16:00:00 GMT。而对于相对时间http中有cache-control: max-age=6000指令，他表示的就是从服务器将文档传来之时，可以认为文档处于新鲜度的秒数。在对比了过期日期之后，如果是我们的牛奶是新鲜的，这时候我们当然可以直接使用了，不需要再去超市买了，也就是说我们可以直接使用缓存的中的副本了，不用再发请求了，这样就很快了。但如果不新鲜了呢？这里的情况可能就稍有不同了，平时我们发现牛奶不新鲜了，可能就会从新去买了。但这样对于我们来说是最好的方式吗？试想一下，虽然我们的缓存过期了，但这个缓存副本的内容依然和我们源服务器上的内容相同，我们是否有必要从新去拿源服务器上的资源呢？当然不需要了，都一样的为啥还要再拿一遍，更新一下我们缓存副本资源的过期日期不就行了，之后继续使用这个版本嘛。这里我们拿缓存中的副本去和源服务器比较的过程就是第三个流程&lt;code&gt;再验证&lt;/code&gt;。如果验证之后，缓存副本和源服务器上的资源不同，这时候我们就可以从新请求资源，放到缓存中了。如果相同，我们只需要更新一下缓存副本的过期日期，继续缓存副本资源。这就是一个缓存的主要流程。下面的流程图中可以看得更清楚。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/cache-tou.png&quot; alt=&quot;setting image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结来说http缓存的全部意义就是提升系统的性能，体现出提升性能的地方主要是后两个阶段：新鲜度检验&lt;code&gt;过期机制&lt;/code&gt;可以减少网络请求回路的数量，再验证&lt;code&gt;验证机制&lt;/code&gt;则可以减少网络应用请求的带宽。&lt;/p&gt;

</description>
        <pubDate>Fri, 06 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/technology/2017/01/06/http-cache.html</link>
        <guid isPermaLink="true">http://localhost:4000/technology/2017/01/06/http-cache.html</guid>
        
        <category>github page jekyll</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>http https 阅读笔记</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;起由&lt;/h3&gt;
&lt;p&gt;最近两年是前端变化大家都有目共睹，是一个各种概念爆发的时期。有时候一两月没有跟进接触学习，发现新出来的代码自己就看不懂了，作为一枚一直从事前端开发的人来说，难免觉得难过。我喜欢研究，所以我喜欢跟着新概念，新技术。但现在来看自己工作的这一年多的时间，我有了许多原来自己不曾有过的焦虑感，我好像给自己搭建了一个很高的梯子，但我搭梯子的架子却不稳固，我站在上面总是缺乏安全感。其实究其本质，是因为我本非科班出生，虽然我的大学号称只有IT一个专业。所以我想后面能抽一部分时间，来补充自己的不足之处，同时也将自己的工作中的一些思考，经验总结一下，大学时候搭建的这个博客，希望自己现在能利用好。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;#&lt;/h3&gt;

</description>
        <pubDate>Fri, 30 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/technology/2016/12/30/http-https-read-notes.html</link>
        <guid isPermaLink="true">http://localhost:4000/technology/2016/12/30/http-https-read-notes.html</guid>
        
        <category>github page jekyll</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>浏览器渲染原理阅读笔记</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1.涉及的浏览器&lt;/h4&gt;
&lt;p&gt;主流的浏览器主要有：Internet Explorer，Firefox，Safari，Chrome，Opera。主要涉及开源浏览器原理。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2.浏览器的主要功能&lt;/h4&gt;
&lt;p&gt;浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里的资源一般是指HTML文档，也可以是PDF，图片或者其他类型。资源的位置由用户使用URI指定。浏览器解释并显示HTML文件的方式是在HTML和CSS规范中指定的。这些规范是由网络标准化组织W3C（万维网联盟）指定。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3.浏览器高层结构&lt;/h4&gt;
&lt;p&gt;浏览器的主要组建有：&lt;br /&gt;
 1. &lt;strong&gt;用户界面&lt;/strong&gt; 主要包括：地址栏，前进/后退按钮，书签菜单等。除了浏览器主窗口显示的您的请求的页面外，其他显示的各个部分都属于用户界面。&lt;br /&gt;
 2. &lt;strong&gt;浏览器引擎&lt;/strong&gt; 在用户界面和呈现引擎直接传送指令。&lt;br /&gt;
 3. &lt;strong&gt;呈现一起&lt;/strong&gt; 负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。&lt;br /&gt;
 4. &lt;strong&gt;网络&lt;/strong&gt;，用于网络调用，比如HTTP请求。其接口与平台无关，并为所有平台提供底层实现。&lt;br /&gt;
 5. &lt;strong&gt;用户界面后端&lt;/strong&gt; 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。&lt;br /&gt;
 6. &lt;strong&gt;JavaScript解析器&lt;/strong&gt; 用于解析和执行JavaScript代码。&lt;br /&gt;
 7. &lt;strong&gt;数据存储&lt;/strong&gt; 这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookie。新的HTML规范（HTML5）定义了”网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。
值得注意的是，和大多数浏览器不同，chrome浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;4.呈现引擎&lt;/h4&gt;
&lt;p&gt;呈现引擎的作用是将请求的内容”呈现”在浏览器的显示屏幕上。默认情况先可以呈现HTML和XML文档和图片，还可以通过浏览器插件的形式显示其他内容，比如PDF等。这里主要介绍主要的用途：&lt;strong&gt;呈现使用CSS格式化的HTML内容和图片&lt;/strong&gt;。&lt;br /&gt;
呈现引擎的主流程：&lt;br /&gt;
呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在8000个快以内。然后进行下面的基本流程：&lt;br /&gt;
 1.&lt;strong&gt;构建呈现树&lt;/strong&gt; 解析HTML文档，并将各个标记逐步转化成”内容树”上的DOM节点。同时也会解析外部CSS文件以及样式元素中的样式数据。HTML中这些带有视觉指令的样式信息将用于创建另一个树结构：&lt;strong&gt;呈现树&lt;/strong&gt;。呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。&lt;br /&gt;
 2. &lt;strong&gt;布局&lt;/strong&gt; 布局处理也就是为每一个节点分配一个应该出现在屏幕上的确切坐标。&lt;br /&gt;
 3. &lt;strong&gt;绘制&lt;/strong&gt; 呈现引擎遍历呈现树，由用户界面后端层将每个几点绘制出来。&lt;br /&gt;
需要注意的地方是，这是一个渐进的过程。为了将内容尽快的呈现在屏幕上，呈现引擎不需要等到整个HTML文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接受和处理来自网络层的其余内容的同时，呈现引擎会将部分内容解析并显示出来。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;5.理解解析&lt;/h4&gt;
&lt;p&gt;解析是呈现引擎中非常重要的一个环节。&lt;br /&gt;
&lt;strong&gt;解析文档&lt;/strong&gt; 是指将文档转化为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作&lt;strong&gt;解析树&lt;/strong&gt;或者&lt;strong&gt;语法树&lt;/strong&gt;。&lt;br /&gt;
&lt;strong&gt;语法&lt;/strong&gt; 解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这成为”与上下文无关的语法”。
&lt;strong&gt;解析器和词法分析的组合&lt;/strong&gt; 解析的过程可以分成两个子过程：&lt;strong&gt;词法分析&lt;/strong&gt;和&lt;strong&gt;语法分析&lt;/strong&gt;。&lt;br /&gt;
  &lt;strong&gt;词法分析&lt;/strong&gt;是指将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言词典中的单词。&lt;br /&gt;
  &lt;strong&gt;语法分析&lt;/strong&gt;是应用语言的语法规则的过程。&lt;br /&gt;
解析器通常将解析工作分给以下两个组建来处理： 词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档结构，从而构建解析树。&lt;br /&gt;
解析是一个迭代的过程。通常，解析器会向词法分线器请求一个新标记，并尝试将与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加的解析树中，然后继续请求下一个标记。
词汇和语法的正式定义：&lt;br /&gt;
词汇通常用正则表达式表示，例如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
INTEGER: 0|[1-9][0-9]
PLUS: +
MINUS: -
&lt;/pre&gt;
&lt;p&gt;语法通常使用一种称为巴科斯范式&lt;a href=&quot;http://baike.baidu.com/link?url=a8Ej6_-69hTEnX815btfMH8hQCPXSXmD5w6PGI2dKtH3v1DK8J7eW6CF5kJxyveIyuu_NTBcIItXOVcdW8DetK&quot;&gt;BNF&lt;/a&gt;的格式来定义。例如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
expression :=  term  operation  term;
operation :=  PLUS | MINUS;
term := INTEGER | expression;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;后面在看一些文章，仔细研究下再来补充&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;html&quot;&gt;HTML解析器&lt;/h4&gt;
&lt;p&gt;HTML解析器的任务是将HTML标记解析成解析树。&lt;br /&gt;
HTML的词法和语法在W3C组织创建的规范中进行了定义。&lt;br /&gt;
正如我们在解析过程的简介中介绍的一样，语法可以用BNF等格式进行正式定义。很遗憾，所有的常规解析器都不试用于HTML(它们可以用于解析CSS和JavaScript)。HTML并不能很容易地用解析器所需的与上下文无关的语法来定义。 &lt;br /&gt;
&lt;strong&gt;DTD&lt;/strong&gt;： 有一种可以定义HTML的正式格式：DTD(Document Type Definition，文档类型定义)，但它不是与上下文无关的语法。 
这看上去有点奇怪：HTML和XML非常相似，那么不是应该有很多XML解析器可以使用吗？区别在于HTML的处理更为”宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和XML严格的语法不同，HTML整体来看是一种”软性”的语法。但这种看上去细微的差别却带来了巨大的影响，一方面，这是HTML如此流行的原因，它能容忍你的错误，简化开发。另一方面，这使得它很难编写正式的语法。概况的说，HTML无法很容易地通过常规解析器解析，也无法通过XML解析器来解析。&lt;br /&gt;
&lt;strong&gt;HTML的定义采用了DTD格式&lt;/strong&gt;： 此格式可用于定义标准通用标记语言&lt;a href=&quot;http://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80?fromtitle=SGML&amp;amp;fromid=2901416&amp;amp;type=syn&quot;&gt;SGML&lt;/a&gt;族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。DTD存在一下变体，严格模式完全遵循HTML规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。&lt;br /&gt;
&lt;strong&gt;DOM&lt;/strong&gt;：HTML解析器的输出”解析树”是由DOM元素和属性节点构成的树结构。DOM是文档对象模型(Document Object Model)的缩写。它是HTML文档的对象表示，同时也是外部内容(例如JavaScript)与HTML元素之间的接口。解析树的根节点是”Document”对象。DOM与标记之间几乎是一一对应的关系。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;解析构建算法&lt;/h4&gt;
&lt;p&gt;后补&lt;/p&gt;

&lt;h4 id=&quot;css&quot;&gt;CSS解析&lt;/h4&gt;
&lt;p&gt;和HTML不同的是，CSS是上下文无关的语法，可以使用已有的集线器进行解析。事实上，CSS规范定义了CSS的语法和词法。 
词法语法(词汇)是针对各个标记用正则表达式定义的，例如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
num:  [0-9]+|[0-9]\*&quot;.&quot;[0-9]+]&quot;&quot;]]
nonascii  [\200-\377]]
nmstart   [\_a-z]|{nonascii}|{escape}
nmchar    [\_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}\*
&lt;/pre&gt;
&lt;p&gt;“ident”是标识符（identifier）的缩写，比如类名。”name”是元素的ID(通过”#”来引用)。&lt;br /&gt;
语法是采用BNF格式描述的。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
rulset
  : selector [ &#39;,&#39; S\* selector ]\*
  &#39;{&#39; S\* declaration [ &#39;;&#39; S\* declaration ]\* &#39;}&#39; S\*
  ;
selector
  : simple\_selector [ combinator selector | S+ [ combinator? selector 
  ]? ]?
  ;
simple\_selector
  : element\_name [ HASH | class | attrib | pseudo ]\*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : &#39;.&#39; IDENT
  ;
element\_name
  : IDENT | &#39;\*&#39;
  ;
attrib
  : &#39;[&#39; S\* IDENT S\* [ [ &#39;=&#39; | INCLUDES | DASHMATCH ] S\*
  [ IDENT | STRING ] S\* ] &#39;]&#39;
  ;
pseudo
  : &#39;:&#39; [ IDENT | FUNCTION S\* [IDENT S\*] &#39;)&#39; ]
  ;
&lt;/pre&gt;

&lt;h4 id=&quot;webkit-css&quot;&gt;WebKit CSS解析器&lt;/h4&gt;
&lt;p&gt;WebKit使用Flex和Bison解析器生成器，通过CSS语法文件自动创建解析器。这两种解析器都会将CSS文件解析成StyleSheet对象，且每个对象都包含CSS规则。CSS规则对象则包含选择器和声明对象，以及其他与CSS语法对应的对象。&lt;br /&gt;
&lt;strong&gt;处理脚本和样式表的顺序&lt;/strong&gt; &lt;br /&gt;
  1. &lt;strong&gt;脚本&lt;/strong&gt; 网络的模型是同步的。网页作者希望解析器遇到script标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络中同步抓去资源完成后再继续。此模型已经使用多年，也在HTML4和HTML5规范中进行了指定。作者也可以将脚本标注为”defer”，这样它可就不会停止文档解析，二是等到解析结束才执行。HTML5增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。&lt;br /&gt;
  2. &lt;strong&gt;预解析&lt;/strong&gt; WebKit和FireFox都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。不过值得注意的是，预解析不会修改DOM树，而是将这项工作交由主解析器处理，而预解析器只会解析外部资源（例如外部脚本，样式表和图片）的引用。&lt;br /&gt;
  3. &lt;strong&gt;样式表&lt;/strong&gt; 另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改DOM树，因此似乎没有必要等待样式表而停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时没有加载解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型的案例，但事实上非常普遍。Firefox在样式表加载和解析的过程中，会禁止所有脚本。而对于WebKit而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。
&lt;strong&gt;呈现树构建&lt;/strong&gt;&lt;br /&gt;
在DOM树构建的同时，浏览器还会构建另一个树结构：&lt;strong&gt;呈现树&lt;/strong&gt;。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。 &lt;br /&gt;
WebKit将呈现树中的元素称为&lt;strong&gt;呈现对象&lt;/strong&gt;（RenderObject）或者&lt;strong&gt;呈现器&lt;/strong&gt;，呈现对象知道如何布局并将自身及其子元素绘制出来。 &lt;br /&gt;
WebKit RenderObject类是所有呈现对象的基类，其定义大致如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node; //the DOM node
  RenderStyle* style; //the computed style
  RenderLayer\* containgLayer; //the containing z-index layer
}
&lt;/pre&gt;
&lt;p&gt;每一个呈现对象都代表了一个矩形的区域，通常对应于相关节点的css框，这一点在CSS规范中有所描述。它包含诸如宽度，高度，位置等几何信息。而且框的类型还会受到与节点相关的”display”样式属性的影响。下面这段WebKit代码描述了根据display属性的不同，针对同一个DOM节点应创建什么类型的呈现对象。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
	Document* doc = node-&amp;gt;document();
	RenderArena* arena = doc-&amp;gt;renderArena();
	...
	RenderObject* o = 0;

	switch (style-&amp;gt;display()) {
		case NONE:
			break;
		case INLINE:
			o = new (arena) RenderInline(node);
			break;
		case BLOCK:
			o = new (arena) RenderBlock(node);
			break;
		case INLINE_BLOCK:
			o = new (arena) RenderBlock(node);
			break;
		case LIST_ITEM:
			o = new (arena) RenderListItem(node);
			break;
			...
	}

	return o;
}
&lt;/pre&gt;
&lt;p&gt;元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框。在WebKit中，如果一个元素特殊的呈对象，就会替换createRender方法。呈现对象所指的样式对象中包含了一些和几何无关的信息。&lt;br /&gt;
&lt;strong&gt;呈现树和DOM树之间的关系&lt;/strong&gt;&lt;br /&gt;
呈现对象是和DOM元素相对应的，但并非一一对应。非可视化的DOM元素不会插入呈现树中，例如”head”元素。如果元素的display属性值为”none”，那么也不会显示在呈现树中（但visibility属性值为”hidden”的元素仍会显示）&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/technology/2016/12/20/technology-browser-render-principles.html</link>
        <guid isPermaLink="true">http://localhost:4000/technology/2016/12/20/technology-browser-render-principles.html</guid>
        
        <category>github page jekyll</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>githubpage + jekyll 搭建自己的博客——简单,专注博文本身</title>
        <description>&lt;p&gt;在github上搭建个人博客是个很有争议的话题，在知乎上也有看到 &lt;a href=&quot;http://www.zhihu.com/question/20717014&quot;&gt;使用 GitHub Pages 来做博客是否道德？&lt;/a&gt; 这类问题。其实道不道德完全在你自己，github本身就是一个开放，分享，交流的平台。如果你的博客本身的目的就是记录分享，这完全符合github的期望，就完全没必要纠结这样的问题。但如果你的目的是商业用途，你完全可以购买github的服务，而不让自己有这种道德包袱。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jekyllcn.com/&quot;&gt;jekyll&lt;/a&gt;用来搭建博客，是很有意思的一种体验，不同wordpress，Ghost，jekyll的所有内容都是静态的，不需要数据库，NO 数据库,使用起来也很简单,但它它最吸引我的是它专注的是博客内容本身，让你的博客更有质量而不是看起来更漂亮，而这正是体验其他博客之后发现自己真正想要的。&lt;/p&gt;

&lt;p&gt;好了，说怎样搭吧:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;在正式搭建之前，这些基础条件你必需要有的：你先要有github帐号，本地装好了git，而且你的本地的git已经成功链接githug；这个过程很简单，先github注册帐号，然后本地装git，最后是建立链接，因为git可以使用的ssh协议，所以你本地生成公钥，提交给github，然后在设置一下帐号信息就好了，相信很多同学都是github的用户，都很熟悉这些了。如果还有疑问可以看这篇文章。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;github新建仓库：&lt;/strong&gt;既然要利用githug的page搭建博客，当然先要让github分配一个可访问的域名了，具体步骤就是登录你github -&amp;gt; New repository：具体可以看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/setting.png&quot; alt=&quot;setting image&quot; /&gt;
这里需要注意的是，域名的形式是&lt;strong&gt;username.github.io&lt;/strong&gt;这里的username要和你github的帐户名相同，因为一个用户只能拥有一个这样的域名的，如果不一致的话，是无法访问的！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If the first part of the repository doesn’t exactly match your username, it won’t work, so make sure to get it right.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;这里因为我已经添加过了，所以有提示name already；正常会显示一个绿色的小勾，说明没有问题了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试访问：&lt;/strong&gt;
如果你这时候访问，发现404；原因很简单，因为你还没有提供任何可供访问的东西，那么怎样为我的bolg添加内容呢？&lt;br /&gt;
你不是已经在github上建立了一个username.github.io的仓库吗，你的博客内容当然也全部放在这个仓库里了，所以先把这个仓库拉到本地了：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ git clone https://github.com/username/username.github.io
&lt;/pre&gt;
&lt;p&gt;OK现在可以为博客加点内容了：&lt;br /&gt;
&lt;?prettify?&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ cd username.github.io
$ touch index.html #这里有必要提供这样一个index.html
$ vim index #随便写点东西 Hello World
&lt;/pre&gt;
&lt;p&gt;当然这只是你本地添加的，接下来你就希望把你刚添加的放到线上，如果按我们平时的习惯，可能就需要cdn之类的部署上线，但因为全是静态的文件，你只需要用git提交到你远程的github下的username.github.io仓库就可以了：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ git add --all
$ git commit -m &quot;initial commit&quot;
$ git push origin master
&lt;/pre&gt;
&lt;p&gt;现在访问你的username.github.io应该就可以看到你刚写的Hello World了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下就是用jekyll搭建你的博客了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装jekyll&lt;/strong&gt;  首先当然你得先装jekyll，因为jekyll是基于ruby的，所以你先得有一个ruby环境，除此之外它还依赖一些其他的环境，你可以一起安装：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ sudo apt-get install ruby ruby-dev make gcc nodejs
&lt;/pre&gt;
&lt;p&gt;之所以会需要&lt;code&gt;node&lt;/code&gt;你可以看一下这个github上的&lt;a href=&quot;https://github.com/jekyll/jekyll/issues/2327&quot;&gt;issue&lt;/a&gt;&lt;br /&gt;
如果你的环境已经搭好，是不是就直接可以安装呢？还有两个坑一定填完了再安装，切记：&lt;br /&gt;
1. linux下的用户，最好不要用packgae安装，因为官方并没有很多好的维护这一块，最好的方式是通过RubyGems来安装，Ruby社区很好的在维护； &lt;br /&gt;
2. 因为网络的原因（你懂的），放在rubygems.org上的资源你可能下载不了，所以你可以换一下rubygems的镜像源，国内&lt;a href=&quot;https://ruby.taobao.org/&quot;&gt;淘宝的rubygems镜像&lt;/a&gt;做很好的，可以替代官方的版本。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ gem sources --remove https://rubygems.org/
$ gem sources -a https://ruby.taobao.org/
$ gem sources -l
https://ruby.taobao.org
# 请确保只有 ruby.taobao.org
&lt;/pre&gt;
&lt;p&gt;如果按照上面说的，环境搭好，而且也换过镜像源了，那么你可以放心安装了；&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ sudo gem install jekyll
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;jekyll写博客&lt;/strong&gt;
现在你可以两种方法使用jekyll New 来新建一个jekyll博客：&lt;br /&gt;
一种是直接到你的username.github.io文件下new一个新博客(不推荐)&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ cd username.github.io
$ jekyll new ./
$ jekyll serve --force_polling 
#这里的--force_polling 是因为jekyll版本更新后--watch不起作用了  
#和--watch一样的功能，旨在开发时监视文件改动并自动更新，不用每  
#次改动都要启动serve
&lt;/pre&gt;
&lt;p&gt;现在可以你打开http://localhost:4000,应该就可以一个初始的jekyll博客了 &lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/images/initial.png&quot; alt=&quot;setting image&quot; /&gt;
当然这也是可以的，但这样会然人觉得缺少一个开发环境，因为改动和提交都在这里，特别是刚开始的去改博客内容时，改动很多，最后想还原也很麻烦；另外一点是，如果你看过jekyll介绍，你会发现jekyll所有最后生成的页面其实都放在_site这个文件中,所以你根本不用把所有文件都放到你的username.github.io仓库中，毕竟github只有300M免费空间。&lt;/p&gt;

&lt;p&gt;正如上面说的，应该有一个开发环境，并且只提交自动生成的博客页面，及_site目录下的文件&lt;br /&gt;
所以这里提供另一种方案&lt;br /&gt;
先新建一个供开发使用的目录及这里的myblog-dev，开发都集中在这个目录下&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ mkdir myblog-dev
$ cd myblog-dev
$ jekyll new ./
$ jekyll serve --force_polling
&lt;/pre&gt;
&lt;p&gt;然后只把自动生成的_site中的文件放到你的username.github.io仓库中；&lt;/p&gt;

&lt;p&gt;当然你也不希望每次改动完了都要把_site里的文件复制到username.github.io中再提交吧。所以你可以设置成让每次在myblod-dev中的修改自动同步到username.github.io中，这样就安心在dev中开发，然后到username.github.io中去提交了。方法是在_config.yaml中添加：&lt;a href=&quot;http://jekyllcn.com/docs/configuration/&quot;&gt;具体&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
source:  .
destination:  ../username.github.io/
&lt;/pre&gt;
&lt;p&gt;修改保存之后&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ cd myblog-dev
$ jekyll build
&lt;/pre&gt;
&lt;p&gt;就可以看到username.github.io下多了生成的我们想要的_site下的文件了，文件目录应该是这样的：&lt;/p&gt;
&lt;pre class=&quot;prettify&quot;&gt;
+username.github.io  
   index.html
   about
   css
   ...
+myblog-dev
   _posts
   _layouts  
   ....
&lt;/pre&gt;
&lt;p&gt;贴一张图可能看的更清楚，&lt;em&gt;里面的music，movie之类的文件夹是我自己的分类&lt;/em&gt;
&lt;img src=&quot;http://localhost:4000/assets/images/list.png&quot; alt=&quot;setting image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来你就可以放心的在本地测开测试，待一切都OK之后，去username.github.io下提交，然后线上也和你本地一样了！&lt;/p&gt;

</description>
        <pubDate>Tue, 05 May 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/technology/2015/05/05/how-to-setup-blog-use-jekyll.html</link>
        <guid isPermaLink="true">http://localhost:4000/technology/2015/05/05/how-to-setup-blog-use-jekyll.html</guid>
        
        <category>github page jekyll</category>
        
        
        <category>technology</category>
        
      </item>
    
  </channel>
</rss>
