<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nani</title>
    <description>我的要博客简单专注有内容。
</description>
    <link>http://nanijiayou.github.io/</link>
    <atom:link href="http://nanijiayou.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 11 Jan 2017 20:27:15 +0800</pubDate>
    <lastBuildDate>Wed, 11 Jan 2017 20:27:15 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>浏览器渲染原理阅读笔记</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;1.涉及的浏览器&lt;/h4&gt;
&lt;p&gt;主流的浏览器主要有：Internet Explorer，Firefox，Safari，Chrome，Opera。主要涉及开源浏览器原理。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2.浏览器的主要功能&lt;/h4&gt;
&lt;p&gt;浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里的资源一般是指HTML文档，也可以是PDF，图片或者其他类型。资源的位置由用户使用URI指定。浏览器解释并显示HTML文件的方式是在HTML和CSS规范中指定的。这些规范是由网络标准化组织W3C（万维网联盟）指定。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3.浏览器高层结构&lt;/h4&gt;
&lt;p&gt;浏览器的主要组建有：&lt;br /&gt;
 1. &lt;strong&gt;用户界面&lt;/strong&gt; 主要包括：地址栏，前进/后退按钮，书签菜单等。除了浏览器主窗口显示的您的请求的页面外，其他显示的各个部分都属于用户界面。&lt;br /&gt;
 2. &lt;strong&gt;浏览器引擎&lt;/strong&gt; 在用户界面和呈现引擎直接传送指令。&lt;br /&gt;
 3. &lt;strong&gt;呈现一起&lt;/strong&gt; 负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。&lt;br /&gt;
 4. &lt;strong&gt;网络&lt;/strong&gt;，用于网络调用，比如HTTP请求。其接口与平台无关，并为所有平台提供底层实现。&lt;br /&gt;
 5. &lt;strong&gt;用户界面后端&lt;/strong&gt; 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。&lt;br /&gt;
 6. &lt;strong&gt;JavaScript解析器&lt;/strong&gt; 用于解析和执行JavaScript代码。&lt;br /&gt;
 7. &lt;strong&gt;数据存储&lt;/strong&gt; 这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookie。新的HTML规范（HTML5）定义了”网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。
值得注意的是，和大多数浏览器不同，chrome浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;4.呈现引擎&lt;/h4&gt;
&lt;p&gt;呈现引擎的作用是将请求的内容”呈现”在浏览器的显示屏幕上。默认情况先可以呈现HTML和XML文档和图片，还可以通过浏览器插件的形式显示其他内容，比如PDF等。这里主要介绍主要的用途：&lt;strong&gt;呈现使用CSS格式化的HTML内容和图片&lt;/strong&gt;。&lt;br /&gt;
呈现引擎的主流程：&lt;br /&gt;
呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在8000个快以内。然后进行下面的基本流程：&lt;br /&gt;
 1.&lt;strong&gt;构建呈现树&lt;/strong&gt; 解析HTML文档，并将各个标记逐步转化成”内容树”上的DOM节点。同时也会解析外部CSS文件以及样式元素中的样式数据。HTML中这些带有视觉指令的样式信息将用于创建另一个树结构：&lt;strong&gt;呈现树&lt;/strong&gt;。呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。&lt;br /&gt;
 2. &lt;strong&gt;布局&lt;/strong&gt; 布局处理也就是为每一个节点分配一个应该出现在屏幕上的确切坐标。&lt;br /&gt;
 3. &lt;strong&gt;绘制&lt;/strong&gt; 呈现引擎遍历呈现树，由用户界面后端层将每个几点绘制出来。&lt;br /&gt;
需要注意的地方是，这是一个渐进的过程。为了将内容尽快的呈现在屏幕上，呈现引擎不需要等到整个HTML文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接受和处理来自网络层的其余内容的同时，呈现引擎会将部分内容解析并显示出来。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;5.理解解析&lt;/h4&gt;
&lt;p&gt;解析是呈现引擎中非常重要的一个环节。&lt;br /&gt;
&lt;strong&gt;解析文档&lt;/strong&gt; 是指将文档转化为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作&lt;strong&gt;解析树&lt;/strong&gt;或者&lt;strong&gt;语法树&lt;/strong&gt;。&lt;br /&gt;
&lt;strong&gt;语法&lt;/strong&gt; 解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这成为”与上下文无关的语法”。
&lt;strong&gt;解析器和词法分析的组合&lt;/strong&gt; 解析的过程可以分成两个子过程：&lt;strong&gt;词法分析&lt;/strong&gt;和&lt;strong&gt;语法分析&lt;/strong&gt;。&lt;br /&gt;
  &lt;strong&gt;词法分析&lt;/strong&gt;是指将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言词典中的单词。&lt;br /&gt;
  &lt;strong&gt;语法分析&lt;/strong&gt;是应用语言的语法规则的过程。&lt;br /&gt;
解析器通常将解析工作分给以下两个组建来处理： 词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档结构，从而构建解析树。&lt;br /&gt;
解析是一个迭代的过程。通常，解析器会向词法分线器请求一个新标记，并尝试将与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加的解析树中，然后继续请求下一个标记。
词汇和语法的正式定义：&lt;br /&gt;
词汇通常用正则表达式表示，例如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
INTEGER: 0|[1-9][0-9]
PLUS: +
MINUS: -
&lt;/pre&gt;
&lt;p&gt;语法通常使用一种称为巴科斯范式&lt;a href=&quot;http://baike.baidu.com/link?url=a8Ej6_-69hTEnX815btfMH8hQCPXSXmD5w6PGI2dKtH3v1DK8J7eW6CF5kJxyveIyuu_NTBcIItXOVcdW8DetK&quot;&gt;BNF&lt;/a&gt;的格式来定义。例如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
expression :=  term  operation  term;
operation :=  PLUS | MINUS;
term := INTEGER | expression;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;后面在看一些文章，仔细研究下再来补充&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;html&quot;&gt;HTML解析器&lt;/h4&gt;
&lt;p&gt;HTML解析器的任务是将HTML标记解析成解析树。&lt;br /&gt;
HTML的词法和语法在W3C组织创建的规范中进行了定义。&lt;br /&gt;
正如我们在解析过程的简介中介绍的一样，语法可以用BNF等格式进行正式定义。很遗憾，所有的常规解析器都不试用于HTML(它们可以用于解析CSS和JavaScript)。HTML并不能很容易地用解析器所需的与上下文无关的语法来定义。 &lt;br /&gt;
&lt;strong&gt;DTD&lt;/strong&gt;： 有一种可以定义HTML的正式格式：DTD(Document Type Definition，文档类型定义)，但它不是与上下文无关的语法。 
这看上去有点奇怪：HTML和XML非常相似，那么不是应该有很多XML解析器可以使用吗？区别在于HTML的处理更为”宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和XML严格的语法不同，HTML整体来看是一种”软性”的语法。但这种看上去细微的差别却带来了巨大的影响，一方面，这是HTML如此流行的原因，它能容忍你的错误，简化开发。另一方面，这使得它很难编写正式的语法。概况的说，HTML无法很容易地通过常规解析器解析，也无法通过XML解析器来解析。&lt;br /&gt;
&lt;strong&gt;HTML的定义采用了DTD格式&lt;/strong&gt;： 此格式可用于定义标准通用标记语言&lt;a href=&quot;http://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80?fromtitle=SGML&amp;amp;fromid=2901416&amp;amp;type=syn&quot;&gt;SGML&lt;/a&gt;族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。DTD存在一下变体，严格模式完全遵循HTML规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。&lt;br /&gt;
&lt;strong&gt;DOM&lt;/strong&gt;：HTML解析器的输出”解析树”是由DOM元素和属性节点构成的树结构。DOM是文档对象模型(Document Object Model)的缩写。它是HTML文档的对象表示，同时也是外部内容(例如JavaScript)与HTML元素之间的接口。解析树的根节点是”Document”对象。DOM与标记之间几乎是一一对应的关系。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;解析构建算法&lt;/h4&gt;
&lt;p&gt;后补&lt;/p&gt;

&lt;h4 id=&quot;css&quot;&gt;CSS解析&lt;/h4&gt;
&lt;p&gt;和HTML不同的是，CSS是上下文无关的语法，可以使用已有的集线器进行解析。事实上，CSS规范定义了CSS的语法和词法。 
词法语法(词汇)是针对各个标记用正则表达式定义的，例如：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
num:  [0-9]+|[0-9]\*&quot;.&quot;[0-9]+]&quot;&quot;]]
nonascii  [\200-\377]]
nmstart   [\_a-z]|{nonascii}|{escape}
nmchar    [\_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}\*
&lt;/pre&gt;
&lt;p&gt;“ident”是标识符（identifier）的缩写，比如类名。”name”是元素的ID(通过”#”来引用)。&lt;br /&gt;
语法是采用BNF格式描述的。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
rulset
  : selector [ &#39;,&#39; S\* selector ]\*
  &#39;{&#39; S\* declaration [ &#39;;&#39; S\* declaration ]\* &#39;}&#39; S\*
  ;
selector
  : simple\_selector [ combinator selector | S+ [ combinator? selector 
  ]? ]?
  ;
simple\_selector
  : element\_name [ HASH | class | attrib | pseudo ]\*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : &#39;.&#39; IDENT
  ;
element\_name
  : IDENT | &#39;\*&#39;
  ;
attrib
  : &#39;[&#39; S\* IDENT S\* [ [ &#39;=&#39; | INCLUDES | DASHMATCH ] S\*
  [ IDENT | STRING ] S\* ] &#39;]&#39;
  ;
pseudo
  : &#39;:&#39; [ IDENT | FUNCTION S\* [IDENT S\*] &#39;)&#39; ]
  ;
&lt;/pre&gt;

&lt;h4 id=&quot;webkit-css&quot;&gt;WebKit CSS解析器&lt;/h4&gt;
&lt;p&gt;WebKit使用Flex和Bison解析器生成器，通过CSS语法文件自动创建解析器。这两种解析器都会将CSS文件解析成StyleSheet对象，且每个对象都包含CSS规则。CSS规则对象则包含选择器和声明对象，以及其他与CSS语法对应的对象。&lt;br /&gt;
&lt;strong&gt;处理脚本和样式表的顺序&lt;/strong&gt; &lt;br /&gt;
  1. &lt;strong&gt;脚本&lt;/strong&gt; 网络的模型是同步的。网页作者希望解析器遇到script标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络中同步抓去资源完成后再继续。此模型已经使用多年，也在HTML4和HTML5规范中进行了指定。作者也可以将脚本标注为”defer”，这样它可就不会停止文档解析，二是等到解析结束才执行。HTML5增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。&lt;br /&gt;
  2. &lt;strong&gt;预解析&lt;/strong&gt; WebKit和FireFox都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。不过值得注意的是，预解析不会修改DOM树，而是将这项工作交由主解析器处理，而预解析器只会解析外部资源（例如外部脚本，样式表和图片）的引用。&lt;br /&gt;
  3. &lt;strong&gt;样式表&lt;/strong&gt; 另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改DOM树，因此似乎没有必要等待样式表而停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时没有加载解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型的案例，但事实上非常普遍。Firefox在样式表加载和解析的过程中，会禁止所有脚本。而对于WebKit而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。
&lt;strong&gt;呈现树构建&lt;/strong&gt;&lt;br /&gt;
在DOM树构建的同时，浏览器还会构建另一个树结构：&lt;strong&gt;呈现树&lt;/strong&gt;。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。 &lt;br /&gt;
WebKit将呈现树中的元素称为&lt;strong&gt;呈现对象&lt;/strong&gt;（RenderObject）或者&lt;strong&gt;呈现器&lt;/strong&gt;，呈现对象知道如何布局并将自身及其子元素绘制出来。 &lt;br /&gt;
WebKit RenderObject类是所有呈现对象的基类，其定义大致如下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node; //the DOM node
  RenderStyle* style; //the computed style
  RenderLayer\* containgLayer; //the containing z-index layer
}
&lt;/pre&gt;
&lt;p&gt;每一个呈现对象都代表了一个矩形的区域，通常对应于相关节点的css框，这一点在CSS规范中有所描述。它包含诸如宽度，高度，位置等几何信息。而且框的类型还会受到与节点相关的”display”样式属性的影响。下面这段WebKit代码描述了根据display属性的不同，针对同一个DOM节点应创建什么类型的呈现对象。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
	Document* doc = node-&amp;gt;document();
	RenderArena* arena = doc-&amp;gt;renderArena();
	...
	RenderObject* o = 0;

	switch (style-&amp;gt;display()) {
		case NONE:
			break;
		case INLINE:
			o = new (arena) RenderInline(node);
			break;
		case BLOCK:
			o = new (arena) RenderBlock(node);
			break;
		case INLINE_BLOCK:
			o = new (arena) RenderBlock(node);
			break;
		case LIST_ITEM:
			o = new (arena) RenderListItem(node);
			break;
			...
	}

	return o;
}
&lt;/pre&gt;
&lt;p&gt;元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框。在WebKit中，如果一个元素特殊的呈对象，就会替换createRender方法。呈现对象所指的样式对象中包含了一些和几何无关的信息。&lt;br /&gt;
&lt;strong&gt;呈现树和DOM树之间的关系&lt;/strong&gt;&lt;br /&gt;
呈现对象是和DOM元素相对应的，但并非一一对应。非可视化的DOM元素不会插入呈现树中，例如”head”元素。如果元素的display属性值为”none”，那么也不会显示在呈现树中（但visibility属性值为”hidden”的元素仍会显示）&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://nanijiayou.github.io/technology/2016/12/20/technology-browser-render-principles.html</link>
        <guid isPermaLink="true">http://nanijiayou.github.io/technology/2016/12/20/technology-browser-render-principles.html</guid>
        
        <category>github page jekyll</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>githubpage + jekyll 搭建自己的博客——简单,专注博文本身</title>
        <description>&lt;p&gt;在github上搭建个人博客是个很有争议的话题，在知乎上也有看到 &lt;a href=&quot;http://www.zhihu.com/question/20717014&quot;&gt;使用 GitHub Pages 来做博客是否道德？&lt;/a&gt; 这类问题。其实道不道德完全在你自己，github本身就是一个开放，分享，交流的平台。如果你的博客本身的目的就是记录分享，这完全符合github的期望，就完全没必要纠结这样的问题。但如果你的目的是商业用途，你完全可以购买github的服务，而不让自己有这种道德包袱。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jekyllcn.com/&quot;&gt;jekyll&lt;/a&gt;用来搭建博客，是很有意思的一种体验，不同wordpress，Ghost，jekyll的所有内容都是静态的，不需要数据库，NO 数据库,使用起来也很简单,但它它最吸引我的是它专注的是博客内容本身，让你的博客更有质量而不是看起来更漂亮，而这正是体验其他博客之后发现自己真正想要的。&lt;/p&gt;

&lt;p&gt;好了，说怎样搭吧:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;在正式搭建之前，这些基础条件你必需要有的：你先要有github帐号，本地装好了git，而且你的本地的git已经成功链接githug；这个过程很简单，先github注册帐号，然后本地装git，最后是建立链接，因为git可以使用的ssh协议，所以你本地生成公钥，提交给github，然后在设置一下帐号信息就好了，相信很多同学都是github的用户，都很熟悉这些了。如果还有疑问可以看这篇文章。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;github新建仓库：&lt;/strong&gt;既然要利用githug的page搭建博客，当然先要让github分配一个可访问的域名了，具体步骤就是登录你github -&amp;gt; New repository：具体可以看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://nanijiayou.github.io/assets/images/setting.png&quot; alt=&quot;setting image&quot; /&gt;
这里需要注意的是，域名的形式是&lt;strong&gt;username.github.io&lt;/strong&gt;这里的username要和你github的帐户名相同，因为一个用户只能拥有一个这样的域名的，如果不一致的话，是无法访问的！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If the first part of the repository doesn’t exactly match your username, it won’t work, so make sure to get it right.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;这里因为我已经添加过了，所以有提示name already；正常会显示一个绿色的小勾，说明没有问题了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试访问：&lt;/strong&gt;
如果你这时候访问，发现404；原因很简单，因为你还没有提供任何可供访问的东西，那么怎样为我的bolg添加内容呢？&lt;br /&gt;
你不是已经在github上建立了一个username.github.io的仓库吗，你的博客内容当然也全部放在这个仓库里了，所以先把这个仓库拉到本地了：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ git clone https://github.com/username/username.github.io
&lt;/pre&gt;
&lt;p&gt;OK现在可以为博客加点内容了：&lt;br /&gt;
&lt;?prettify?&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ cd username.github.io
$ touch index.html #这里有必要提供这样一个index.html
$ vim index #随便写点东西 Hello World
&lt;/pre&gt;
&lt;p&gt;当然这只是你本地添加的，接下来你就希望把你刚添加的放到线上，如果按我们平时的习惯，可能就需要cdn之类的部署上线，但因为全是静态的文件，你只需要用git提交到你远程的github下的username.github.io仓库就可以了：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ git add --all
$ git commit -m &quot;initial commit&quot;
$ git push origin master
&lt;/pre&gt;
&lt;p&gt;现在访问你的username.github.io应该就可以看到你刚写的Hello World了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下就是用jekyll搭建你的博客了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装jekyll&lt;/strong&gt;  首先当然你得先装jekyll，因为jekyll是基于ruby的，所以你先得有一个ruby环境，除此之外它还依赖一些其他的环境，你可以一起安装：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ sudo apt-get install ruby ruby-dev make gcc nodejs
&lt;/pre&gt;
&lt;p&gt;之所以会需要&lt;code&gt;node&lt;/code&gt;你可以看一下这个github上的&lt;a href=&quot;https://github.com/jekyll/jekyll/issues/2327&quot;&gt;issue&lt;/a&gt;&lt;br /&gt;
如果你的环境已经搭好，是不是就直接可以安装呢？还有两个坑一定填完了再安装，切记：&lt;br /&gt;
1. linux下的用户，最好不要用packgae安装，因为官方并没有很多好的维护这一块，最好的方式是通过RubyGems来安装，Ruby社区很好的在维护； &lt;br /&gt;
2. 因为网络的原因（你懂的），放在rubygems.org上的资源你可能下载不了，所以你可以换一下rubygems的镜像源，国内&lt;a href=&quot;https://ruby.taobao.org/&quot;&gt;淘宝的rubygems镜像&lt;/a&gt;做很好的，可以替代官方的版本。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ gem sources --remove https://rubygems.org/
$ gem sources -a https://ruby.taobao.org/
$ gem sources -l
https://ruby.taobao.org
# 请确保只有 ruby.taobao.org
&lt;/pre&gt;
&lt;p&gt;如果按照上面说的，环境搭好，而且也换过镜像源了，那么你可以放心安装了；&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ sudo gem install jekyll
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;jekyll写博客&lt;/strong&gt;
现在你可以两种方法使用jekyll New 来新建一个jekyll博客：&lt;br /&gt;
一种是直接到你的username.github.io文件下new一个新博客(不推荐)&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ cd username.github.io
$ jekyll new ./
$ jekyll serve --force_polling 
#这里的--force_polling 是因为jekyll版本更新后--watch不起作用了  
#和--watch一样的功能，旨在开发时监视文件改动并自动更新，不用每  
#次改动都要启动serve
&lt;/pre&gt;
&lt;p&gt;现在可以你打开http://localhost:4000,应该就可以一个初始的jekyll博客了 &lt;br /&gt;
&lt;img src=&quot;http://nanijiayou.github.io/assets/images/initial.png&quot; alt=&quot;setting image&quot; /&gt;
当然这也是可以的，但这样会然人觉得缺少一个开发环境，因为改动和提交都在这里，特别是刚开始的去改博客内容时，改动很多，最后想还原也很麻烦；另外一点是，如果你看过jekyll介绍，你会发现jekyll所有最后生成的页面其实都放在_site这个文件中,所以你根本不用把所有文件都放到你的username.github.io仓库中，毕竟github只有300M免费空间。&lt;/p&gt;

&lt;p&gt;正如上面说的，应该有一个开发环境，并且只提交自动生成的博客页面，及_site目录下的文件&lt;br /&gt;
所以这里提供另一种方案&lt;br /&gt;
先新建一个供开发使用的目录及这里的myblog-dev，开发都集中在这个目录下&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ mkdir myblog-dev
$ cd myblog-dev
$ jekyll new ./
$ jekyll serve --force_polling
&lt;/pre&gt;
&lt;p&gt;然后只把自动生成的_site中的文件放到你的username.github.io仓库中；&lt;/p&gt;

&lt;p&gt;当然你也不希望每次改动完了都要把_site里的文件复制到username.github.io中再提交吧。所以你可以设置成让每次在myblod-dev中的修改自动同步到username.github.io中，这样就安心在dev中开发，然后到username.github.io中去提交了。方法是在_config.yaml中添加：&lt;a href=&quot;http://jekyllcn.com/docs/configuration/&quot;&gt;具体&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
source:  .
destination:  ../username.github.io/
&lt;/pre&gt;
&lt;p&gt;修改保存之后&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ cd myblog-dev
$ jekyll build
&lt;/pre&gt;
&lt;p&gt;就可以看到username.github.io下多了生成的我们想要的_site下的文件了，文件目录应该是这样的：&lt;/p&gt;
&lt;pre class=&quot;prettify&quot;&gt;
+username.github.io  
   index.html
   about
   css
   ...
+myblog-dev
   _posts
   _layouts  
   ....
&lt;/pre&gt;
&lt;p&gt;贴一张图可能看的更清楚，&lt;em&gt;里面的music，movie之类的文件夹是我自己的分类&lt;/em&gt;
&lt;img src=&quot;http://nanijiayou.github.io/assets/images/list.png&quot; alt=&quot;setting image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来你就可以放心的在本地测开测试，待一切都OK之后，去username.github.io下提交，然后线上也和你本地一样了！&lt;/p&gt;

</description>
        <pubDate>Tue, 05 May 2015 00:00:00 +0800</pubDate>
        <link>http://nanijiayou.github.io/technology/2015/05/05/how-to-setup-blog-use-jekyll.html</link>
        <guid isPermaLink="true">http://nanijiayou.github.io/technology/2015/05/05/how-to-setup-blog-use-jekyll.html</guid>
        
        <category>github page jekyll</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>对人工智能的思考</title>
        <description>&lt;p&gt;人工智能&lt;/p&gt;

</description>
        <pubDate>Mon, 04 May 2015 00:00:00 +0800</pubDate>
        <link>http://nanijiayou.github.io/think/2015/05/04/think.html</link>
        <guid isPermaLink="true">http://nanijiayou.github.io/think/2015/05/04/think.html</guid>
        
        
        <category>think</category>
        
      </item>
    
      <item>
        <title>贰百 狗日的青春</title>
        <description>&lt;p&gt;狗日的青春&lt;/p&gt;
</description>
        <pubDate>Mon, 04 May 2015 00:00:00 +0800</pubDate>
        <link>http://nanijiayou.github.io/music/2015/05/04/music.html</link>
        <guid isPermaLink="true">http://nanijiayou.github.io/music/2015/05/04/music.html</guid>
        
        
        <category>music</category>
        
      </item>
    
      <item>
        <title>蝙蝠侠-黑暗骑士</title>
        <description>&lt;p&gt;小丑！太帅&lt;/p&gt;
</description>
        <pubDate>Mon, 04 May 2015 00:00:00 +0800</pubDate>
        <link>http://nanijiayou.github.io/movie/2015/05/04/moive.html</link>
        <guid isPermaLink="true">http://nanijiayou.github.io/movie/2015/05/04/moive.html</guid>
        
        
        <category>movie</category>
        
      </item>
    
      <item>
        <title>海边的卡夫卡——村上春树</title>
        <description>&lt;p&gt;海边的卡夫卡&lt;/p&gt;
</description>
        <pubDate>Mon, 04 May 2015 00:00:00 +0800</pubDate>
        <link>http://nanijiayou.github.io/book/2015/05/04/book.html</link>
        <guid isPermaLink="true">http://nanijiayou.github.io/book/2015/05/04/book.html</guid>
        
        
        <category>book</category>
        
      </item>
    
  </channel>
</rss>
